### JavaScript 

## ‚öôÔ∏è JavaScript Runtime Components

**1. Call Stack (Execution Stack)**
Manages function calls in a LIFO order.

Every time a function is called, it‚Äôs pushed to the stack.

When the function returns, it‚Äôs popped from the stack.

Maximum call stack size about 16000, if you recursively call empty recursive function chrome will stop the execution with 
Range Error: Maximum call stack size exceeded

**2. Heap**
A region in memory where objects, functions, and closures are stored.

Unstructured, unlike the call stack.

Used for memory allocation of complex data.

**3. Web APIs (in browsers) / Node APIs (in Node.js)**
These are external environments that handle things JavaScript itself cannot.

**Examples:**

- setTimeout
- DOM events
- fetch, XMLHttpRequest
- console.log

Provided by the browser (e.g., Chrome‚Äôs V8 + Web APIs) or Node.js runtime.

4. Callback Queue / Task Queue
Stores callback functions that are ready to be run after Web APIs complete.

Examples:

Timer callbacks (setTimeout, setInterval)

I/O callbacks

DOM events

5. Event Loop
The traffic controller between the call stack and the callback queue.

Continuously checks if the call stack is empty and pushes the next task from the callback queue to the stack.

6. Microtask Queue
A separate queue that holds promises' .then(), .catch(), async/await callbacks.

Has priority over the callback queue (task queue).

All microtasks are processed before moving to the next macro task.

üìä Diagram Overview
sql
Copy
Edit
+---------------------+
|     Call Stack      | <--------+     
+---------------------+          |       
                                 | executes
+---------------------+          |
|    Web APIs         | -----> Callback Queue
| (Timers, DOM, etc.) |          |
+---------------------+          |
                                 |
+---------------------+          |    
|   Microtask Queue   | <--------+  Event Loop
+---------------------+
üîÅ Example Flow
javascript
Copy
Edit
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");
Output:

Start
End
Promise
Timeout


### var vs let vs const

- use let if you need to reassign
- use const if you don't need to reassign


# scope
var - function scope, within function or any nested function

let and const - has block({}) scope, can be accessed within the block they were defined


# var issues
- allows to re-declare and reassign the variable


## difference between `==` and `===`
== lose equality comparison operator in JavaScript and it will do type coercion if needed
5 == "5" // true

5 === "5" // false

In summary, == compares values after doing type conversion if necessary, while === compares values without doing any type conversion.

## what is the difference between `block` and `inline`?
Block and inline are two display values in CSS that specify how an element should be displayed on a web page.

A block-level element takes up the full width of its parent container and creates a new line after it. These elements typically use the entire available width and do not allow any other elements to display beside them. Examples of block-level elements include <div>, <h1> - <h6>, <p>, <ul>, <ol>, <li>, <table>, <form>, and others.

On the other hand, inline elements only take up the required width of their content and do not cause a line break after them. These elements typically allow other elements to display beside them on the same line. Examples of inline-level elements include <span>, <a>, <strong>, <em>, <img>, <input>, <button>, and others.

## Same Site Cookie attribute

The SameSite attribute on cookies is a security feature that helps prevent Cross-Site Request Forgery (CSRF) attacks by controlling how cookies are sent with cross-site requests.

The SameSite attribute tells the browser when and how to include cookies in cross-site HTTP requests (like those initiated from a different domain).

Values are 'Strict', 'Lax', 'None'


### What happens when we enter an url in the browser

üåê 1. URL Parsing
Browser checks if the input is a full URL (https://www.example.com) or a search query.

If it's a search query, it redirects to the default search engine.

If it‚Äôs a URL, it parses:

Protocol: https

Hostname: www.example.com

Path: / (default if not specified)

üì¶ 2. DNS Lookup
The browser checks the DNS cache (browser ‚Üí OS ‚Üí router ‚Üí ISP).

If no cached IP is found:

A DNS query is sent to a DNS resolver.

Resolver returns the IP address of www.example.com.

üì° 3. TCP Connection Setup
Browser opens a TCP connection to the server IP using port 443 (for HTTPS).

This involves a 3-way handshake:

Client: SYN ‚Üí

Server: SYN-ACK ‚Üí

Client: ACK

üîê 4. TLS Handshake (For HTTPS)
Browser initiates TLS handshake:

Exchange of certificates

Public/private key negotiation

Session key is agreed upon

Secure encrypted connection is established.

üì§ 5. HTTP Request Sent
Browser sends a GET request to the server:

http
Copy
Edit
GET / HTTP/1.1
Host: www.example.com
User-Agent: Chrome/120.0
Accept: text/html
...
üì• 6. Server Processes Request
The server:

Looks up the requested path /

Generates or fetches the response (HTML, JSON, etc.)

Sends back an HTTP response:

http
Copy
Edit
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1240
...
<html>...</html>
üß† 7. Browser Renders Content
The browser:

Parses the HTML.

Makes additional requests for:

CSS, JS, images, fonts, etc.

Applies CSS rules, executes JS.

Builds the DOM, CSSOM, and renders the page.

‚öôÔ∏è 8. Caching, Cookies, and Storage
Browser may:

Store resources in cache for future use.

Read/write cookies, localStorage, or sessionStorage.

‚è±Ô∏è Optional: Performance Optimizations
Preload, prefetch, lazy load resources

Use HTTP/2 multiplexing to fetch multiple assets in one connection


### Array.prototype.forEach() vs Array.prototype.map()

1. Array.prototype.forEach()
Purpose: Executes a provided function once for each array element.

Returns: undefined (does not return a new array).

Use case: When you want to perform side effects (like logging, updating variables, modifying external state) for each item, but not transform the array.

Example:

js
Copy
Edit
const numbers = [1, 2, 3];
numbers.forEach((num) => {
  console.log(num * 2);  // Just logging, no new array created
});

2. Array.prototype.map()
Purpose: Creates a new array by applying a function to each element of the original array.

Returns: A new array with transformed elements.

Use case: When you want to transform the array into a new one without mutating the original.

Example:

const numbers = [1, 2, 3];
const doubled = numbers.map((num) => num * 2);
console.log(doubled);  // [2, 4, 6]


### Cookie vs localStorage vs sessionStorage
**üîê 1. Cookie**
Purpose: Mainly used for server-client communication (especially for authentication).

Size Limit: ~4 KB.

Persistence: You can set expiry ‚Äî by default, it's a session cookie (expires when the browser closes).

Accessible From: JavaScript (document.cookie) and automatically sent with every HTTP request to the server.

Use Case: Login tokens, session IDs, tracking data.

Example:

document.cookie = "username=John; expires=Fri, 31 Dec 2025 23:59:59 GMT; path=/";

**üíæ 2. localStorage**
Purpose: Store data persistently in the browser (client-side only).

Size Limit: ~5‚Äì10 MB (depends on browser).

Persistence: Data persists even after closing the browser.

Accessible From: Only via JavaScript (window.localStorage); not sent to the server automatically.

Use Case: Storing user preferences, dark mode setting, caching data locally.

Example:

localStorage.setItem("theme", "dark");
const theme = localStorage.getItem("theme"); // "dark"


**üì¶ 3. sessionStorage**
Purpose: Store data for a single browser tab or session.

Size Limit: ~5 MB.

Persistence: Cleared when the tab is closed.

Accessible From: Only via JavaScript (window.sessionStorage); not shared across tabs.

Use Case: Temporary state, form data between page navigations within the same tab.

sessionStorage.setItem("step", "2");
const step = sessionStorage.getItem("step"); // "2"

### What is CSRF (Cross-Site Request Forgery)?

CSRF (Cross-Site Request Forgery) is a type of web security vulnerability that tricks a logged-in user into unknowingly submitting malicious actions on a website where they're authenticated.

üß† Example of a CSRF Attack:
Imagine a user is logged into their bank account at mybank.com. While logged in, they visit a malicious website (evil.com) that contains a hidden form like:

<form action="https://mybank.com/transfer" method="POST">
  <input type="hidden" name="amount" value="1000">
  <input type="hidden" name="to_account" value="attacker123">
  <input type="submit">
</form>

<script>
  document.forms[0].submit(); // Automatically submits the form
</script>

Since the user is already logged in, their browser automatically sends session cookies (e.g., authToken), and the server thinks it's a legitimate request from the user.

üö® What Can Attackers Do with CSRF?
Transfer money

Change account passwords

Modify user details

Delete user accounts

Make purchases

Anything the user is authorized to do can potentially be hijacked.

üõ°Ô∏è How to Prevent CSRF?
1. CSRF Tokens (Synchronizer Token Pattern) ‚úÖ
Generate a unique token for each user session and include it in forms or AJAX requests.

The server checks this token before processing the request.
<form action="/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="abc123">
</form>

// Example check on server (pseudo-code)
if (request.csrf_token !== session.csrf_token) {
  reject("Invalid CSRF token");
}

2. SameSite Cookie Attribute ‚úÖ
Use SameSite=Strict or SameSite=Lax in cookies to prevent cross-origin requests from including cookies.

Set-Cookie: sessionId=abc123; SameSite=Strict; Secure; HttpOnly
3. Double Submit Cookie
Set the CSRF token in both a cookie and a custom header or hidden form field, and validate both on the server.

4. Custom Headers (for AJAX)
Require X-CSRF-Token or similar custom headers that can't be set cross-origin via HTML forms.

5. User Confirmation
For sensitive actions (like delete/transfer), ask the user to confirm with a password or OTP.

6. Check Referer or Origin Header
Ensure the request's origin matches your site‚Äôs origin.


### How to Publish an NPM Package

üîß 1. Setup Project Directory
mkdir my-awesome-package
cd my-awesome-package
npm init

This creates a package.json file. Fill in the details:

name: Must be unique on npm.

version: Start with 1.0.0.

main: Entry point (e.g., index.js).

description, author, license: Optional but recommended.

üìÅ 2. Create Your Code
Create the main file, e.g., index.js:
// index.js
function sayHello(name) {
  return `Hello, ${name}!`;
}

module.exports = sayHello;

üì¶ 3. Create .npmignore (Optional)
Similar to .gitignore, this prevents unnecessary files from being published.
node_modules
test/
.env

üîê 4. Login to npm
If you don‚Äôt have an account yet, sign up here.

Then in your terminal:
npm login

üöÄ 5. Publish Your Package
Make sure your package name is unique (npm will reject duplicates).

To publish:
npm publish

For scoped packages (e.g., @yourname/package-name), use:
npm publish --access public

üÜï 6. Updating the Package
Bump the version in package.json (npm version patch|minor|major)

Then re-publish:
npm version patch   # e.g., 1.0.0 ‚Üí 1.0.1
npm publish

üîç 7. Verify Your Package
Visit https://www.npmjs.com/package/your-package-name

Install it anywhere to test:
npm install your-package-name

Use it:

const sayHello = require('your-package-name');
console.log(sayHello('World')); // Hello, World!

### this call() bind() apply()
üß† What is this?
In JavaScript, this refers to the object that is "calling" the function. Sometimes, we want to manually set this, and that‚Äôs where call, apply, and bind come in.


### Explain Box Model

+---------------------------+
|       Margin              |
|  +---------------------+  |
|  |     Border          |  |
|  |  +---------------+  |  |
|  |  |   Padding     |  |  |
|  |  |  +---------+  |  |  |
|  |  |  | Content  |  |  |  ‚Üê actual text/image/etc.
|  |  |  +---------+  |  |  |
|  |  +---------------+  |  |
|  +---------------------+  |
+---------------------------+

